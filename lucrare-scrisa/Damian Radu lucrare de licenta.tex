\documentclass[12pt,a4paper]{report}

\usepackage{graphicx}
\usepackage{ragged2e}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{comment}
\usepackage{biblatex}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{float}
\usepackage{listings}
\addbibresource{sample.bib}

\geometry{
 a4paper,
 total={170mm,257mm},
 left=25mm,
 right=25mm,
 top=20mm,
 }

\newcommand\myrepeat[2]{%
  \begingroup
  \lccode`m=`#2\relax
  \lowercase\expandafter{\romannumeral#1000}%
  \endgroup
}
\linespread{1.213}
\begin{document}
\begin{comment}Copertă 
\end{comment}
\begin{titlepage}
	\centering
	{\scshape\large \textbf{UNIVERSITATEA "ALEXANDRU IOAN CUZA" DIN IAȘI} \par}
	\vspace{0.5cm}
	{\scshape\Large \textbf{FACULTATEA DE INFORMATICĂ}\par}
	\vspace{2cm}
	\includegraphics[width=0.15\textwidth]{logo-fii}\par\vspace{1cm}
	{\scshape\normalsize LUCRARE DE LICENȚĂ\par}
	\vspace{1cm}
	{\huge\bfseries Gemixque\par}
	\vspace{1cm}
	{\normalsize \textbf{sistem de recomandări de jocuri video}\par}
	\vspace{1.5cm}
	{\normalsize \textbf{propusă de}\par}
	\vspace{1cm}
	{\Large\itshape\textbf {Radu Damian}\par}
	\vspace{2cm}
	{\normalsize \textbf{Sesiunea:} \textit{iunie/iulie, 2022}\par}
	\vspace{1cm}
	{\normalsize \textbf{Coordonator științific}\par}
	\vspace{0.5cm}
	{\Large\itshape\textbf {Lect.dr. Cristian Frăsinaru}\par}
\end{titlepage}

\begin{comment}Prima pagină
\end{comment} 
\begin{titlepage}
	\centering
	{\scshape\large \textbf{UNIVERSITATEA "ALEXANDRU IOAN CUZA" DIN IAȘI} \par}
	\vspace{0.5cm}
	{\scshape\Large \textbf{FACULTATEA DE INFORMATICĂ}\par}
	\vspace{5cm}


	{\huge\bfseries Gemixque\par}
	\vspace{1cm}
	{\normalsize \textbf{sistem de recomandări de jocuri video}\par}
	\vspace{3cm}
	{\Large\itshape\textbf {Radu Damian}\par}
	\vspace{2cm}
	{\normalsize \textbf{Sesiunea:} \textit{iunie/iulie, 2022}\par}
	\vspace{4cm}
	{\normalsize \textbf{Coordonator științific}\par}
	\vspace{0.5cm}
	{\Large\itshape\textbf {Lect.dr. Cristian Frăsinaru}\par}
\end{titlepage}

\begin{comment}Declarație standard privind originalitatea lucrării
\end{comment}
\begin{titlepage} 


	\begin{FlushRight}Avizat,\end{FlushRight}
	\begin{FlushRight}Îndrumător Lucrare de Licență				\end{FlushRight}
	\begin{FlushRight}Titlul, Numele și Prenume \hspace{2em}	\rule{5cm}{0.15mm}
	\end{FlushRight}

	\begin{FlushRight}Data \rule{2cm}{0.15mm} \hspace{2em} 	Semnătura \rule{2cm}{0.15mm} \end{FlushRight}

	\hfill \break

	\begin{center}
	\textbf{DECLARAȚIE privind originalitatea conținutului 	lucrării de licență}
	\end{center}
	
	
	\justifying
	\hspace{1em} Subsemnatul(a) \hspace{1em} \myrepeat{90}{.} \newline
	domiciliul în \myrepeat{90}{.} \newline
	născut(ă) la data de \myrepeat{30}{.},\hspace{1em} identificat prin CNP 
\myrepeat{40}{.},
	absolvent(a) al(a) Universității "Alexandru Ioan Cuza" din Iași, \newline
	 Facultatea de \myrepeat{30}{.} \hspace{1em} specializarea \hspace{1em} \myrepeat{55}{.},
	 promoția \hspace{1em} \myrepeat{30}{.}, declar pe propria
	 răspundere, cunoscând consecințele \newline falsului în
	 declarații în sensul art. 326 din Noul Cod Penal și 
	 dispozițiile Legii Educației Naționale nr. 1/2011
	 art.143 al. 4 si 5 referitoare la plagiat, că lucrarea de
	 licență cu titlul: \rule{16cm}{0.15mm} \newline
	 \rule{16cm}{0.15mm} \newline
	 elaborată sub îndrumarea dl. / d-na \rule{9.3cm}{0.15mm}
	 \newline pe care urmează să o susțină în fața
	 comisiei este originală, îmi aparține și îmi asum 				 conținutul său în întregime. 
	 
	 \hspace{1em} De asemenea, declar că sunt de acord ca
	 lucrarea mea de licență să fie verificată prin orice
	 modalitate legală pentru confirmarea originalității,
	 consimțind inclusiv la introducerea conținutului său
	 într-o bază de date în acest scop.
	 
	 \hspace{1em} Am luat la cunoștință despre faptul că este interzisă
	 comercializarea de lucrări științifice în vederea
	 facilitării falsificării de către cumpărător a calității
	 de autor al unei lucrări de licență, de diplomă sau de
	 disertație în acest sens, declar pe proprie răspundere
	 că lucrarea de față nu a fost copiată ci reprezintă rodul 
	 cercetării i pe care am întreprins-o.
	 
	 \hfill \break
	 
	 \hspace{1em} Dată azi, \myrepeat{30}{.}
	 \hspace{5em} Semnătură student \myrepeat{30}{.}
	 
\end{titlepage}

\begin{comment}Declarație standard privind drepturile de utilizare a lucrării și a codului sursă
\end{comment}
\begin{titlepage}
	\hfill \break
	\begin{center}
	DECLARAȚIE DE CONSIMȚĂMÂNT
	\end{center}
	
	\hfill \break
	\justifying
	Prin prezenta declar că sunt de acord ca Lucrarea de
	licență cu titlul \emph{"Gemixque"},
	codul sursă al programelor și celelalte conținuturi
	(grafice, multimedia, date de test etc.) care însoțesc
	această lucrare să fie utilizate în cadrul Facultății
	de Informatică.
	
	De asemenea, sunt de acord ca Facultatea de Informatică
	de la Universitatea "Alexandru Ioan Cuza" din Iași,
	să utilizeze, modifice, reproducă și să distribuie în
	scopuri necomerciale programele-calculator, format
	executabil și sursă, realizate de mine în cadrul prezentei
	lucrări de licență.
	
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	Iași, \emph{data}
	
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\begin{FlushRight}Absolvent  \emph{Radu Damian} \end{FlushRight}
	\begin{FlushRight}\rule{4.5cm}{0.15mm} \end{FlushRight}
	\begin{FlushRight}(semnătura în original) \end{FlushRight}
	
	
\end{titlepage}

\hfill \break
	\begin{center}
	{\scshape\large \textbf{Mulțumiri} \par}
	\end{center}
	
\begin{flushright}
\hfill \break
\hfill \break
Sunt profund recunoscător pentru sprijinul necondiționat oferit de părinții și de bunica mea în vederea realizării acestei lucrări de licență.
\end{flushright}
\hfill \break
\hfill \break
\hfill \break
\begin{flushright}
Îi mulțumesc Monicăi pentru faptul că m-a ajutat să-mi gestionez trăirile și să privesc provocările pe care le-am întâmpinat cu o atitudine sănătoasă.
\hfill \break
\hfill \break
\hfill \break
\end{flushright}
\begin{flushright}
De asemenea, îi mulțumesc domnului prof. dr Frăsinaru Cristian, îndrumător al lucrării de licență, pentru sfaturile, resursele, și încrederea oferită de-a lungul perioadei în care am lucrat pentru licență.
\end{flushright}

\newpage
   
\renewcommand*{\contentsname}{Cuprins}
\tableofcontents
\newpage

\hfill \break

	\hfill \break
	\begin{center}
	{\scshape\large \textbf{Introducere} \par}
	\end{center}
	
	Această lucrare de licență propune prezentarea implementării unui sistem de recomandare, sub forma unei aplicații web.
	
	În următoarele capitole vor fi ilustrate următoarele: problema ce trebuie rezolvată, tehnologiile folosite, modelarea bazei de date, modul în care au fost generate datele de intrare ale problemei, server-ul de back-end, algoritmul implementat și server-ul de front-end.
	
	\begin{center}
	{\scshape\large \textbf{Motivație} \par}
	\end{center}

	Ideea de bază a lucrării de licență a venit oarecum din întâmplare. Când eram student în semestrul II din anul 2 de facultate, mă uitasem într-o zi obișnuită la acest site: \href{https://simkl.com/}{https://simkl.com}, pe care-l foloseam pentru a nu uita la ce episod am rămas dintr-un anumit serial. Acest site poate oferi și recomandări de filme/seriale în funcție de datele din profilul meu.
	
	Fiind un amator de jocuri video pe PC, mi-a venit ideea de a face un astfel de site, însă care să recomande, bineînțeles, jocuri video.
	
	O observație importantă este faptul că aș fi putut alege orice resursă ce poate fi recomandată(de exemplu: periuțe de dinți, telefoane, picturi etc.), așadar problema în speță poate fi privită într-un mod mai general. Motivul pentru care am ales jocurile video este dat de pasiunea mea pentru acestea.
	
	De asemenea, eram curios în acea perioadă, printre altele, legat de cum aș putea implementa o soluție pentru acest sistem de recomandare pe care mi l-am propus să-l realizez.
	
	Așadar, am avut inspirație, dar și noroc, deoarece această idee mi-a venit relativ repede, lucru ce a reprezentat un punct de pornire important în realizarea efectivă a acestei lucrări.
	
	\newpage
	
	\begin{center}
	{\scshape\large \textbf{Aplicații similare} \par}
	\end{center}
	
	Din aplicațiile similare căutate, am identificat următoarele pe care le-am considerat mai notabile:
	
\begin{itemize}
  \item IGDB - \url{https://www.igdb.com/}
  \item Steam - \url{https://store.steampowered.com/}
  \item Metacritic - \url{https://www.metacritic.com/}
  \item Quantic Foundry - \url{https://quanticfoundry.com/}
  \item Games finder - \url{https://gameslikefinder.com/}
\end{itemize}


Încercând să caut informații legate de modul concret de implementare al recomandărilor care se regăsesc în aceste aplicații, mi-am dat seama că acest lucru este în zadar, din cauza aspectului comercial al aplicațiilor.

Chiar și așa, aplicația ce va fi prezentată în această lucrare de licență are un algoritm de recomandare ce a necesitat o documentare în prealabil, și utilizează de asemenea o bază de date nerelațională de tip graf.

Așadar, aplicația propusă s-ar putea descrie mai degrabă ca o tentativă de a îmi răspunde la următoarea întrebare care nu mi-a fost răspunsă consultând aplicațiile similare: Cum se poate implementa un algoritm de recomandare?

Bineînțeles că răspunsul nu este unul universal, ci propun o variantă(din nenumăratele care pot exista, căci este loc de inovații și contribuții semnificative în a ataca această problemă) care a fost șlefuită folosind resurse proprii.

În timpul implementării aplicației, mi-am dat seama că răspunsul meu poate fi privit doar ca un punct de pornire pentru a dezvolta în continuare partea de recomandare a aplicației. Aceste reflecții pot fi regăsite în capitolul \textbf{Concluzii și direcții viitoare}.
	
	
\newpage
	
\setcounter{secnumdepth}{3} 
\renewcommand*\thesection{\arabic{section}}
\section{Descrierea problemei}

Problema ce trebuie rezolvată se rezumă la recomandarea unor jocuri video(niciunul, unul, sau mai multe) unui utilizator. În ansamblu, datele de intrare ar putea fi reprezentate de o mulțime de jocuri video, o mulțime de utilizatori și o mulțime de recenzii.

Aceste recenzii sunt oferite de utilizator și asociate unui joc. În recenzie, utilizatorul oferă o notă(un scor, pe o scară de la 1 la 10) care indică cât de mult i-a plăcut/displăcut jocul respectiv. Un utilizator poate face maxim o recenzie per joc.

O descriere mai amănunțită a utilizatorilor, recenzilor și a jocurilor se poate regăsi în capitolul 4 \textbf{Baza de date}, subcapitolul \textbf{Modelarea bazei de date}.

\subsection{Scopuri și cerințe ale aplicației}

\bigskip
\bigskip
\textbf{Scopul documentului}
\bigskip

Scopul acestui document este de a ilustra modul în care funcționează un sistem de recomandări de jocuri video sub forma unei aplicații web având ca soluție de stocare o bază de date de tip graf NoSql.

\bigskip
\textbf{Publicul țintă}
\bigskip

Acest document este destinat atât cititorilor avizați(e.g. profesori universitari) pentru a afla de exemplu soluțiile utilizate în cadrul capitolelor 4, 5 sau 6, \textbf{Baza de date}, \textbf{Back-end} respectiv \textbf{Algoritmul de recomandare}, cât și cititorilor neavizați(utilizatori obișnuiți), care se pot informa în legătură cu modul în care pot interacționa cu site-ul în capitolul 8 \textbf{Manual de utilizare}.

\bigskip
\textbf{Scopul aplicației}
\bigskip

Scopul acestei aplicații este de a oferi o soluție în a contracara cantitatea masivă de informații ce se regăsește pe internet \cite{5} în ceea ce privește multitudinea de jocuri video, prin a dezvolta un sistem de recomandări care să faciliteze decizia unui utilizator legat de ce joc să aleagă.

\bigskip
\textbf{Contribuții}
\bigskip  

Generarea datelor de intrare ale problemei a fost realizată de mine, în sensul că nu am folosit în mod direct seturi de date externe(de exemplu: Kaggle), ci am implementat un modul în Java care generează fișiere tip csv.

De asemenea, implementarea algoritmului a fost făcută fără utilizarea unei librării externe(cum s-ar fi putut face de exemplu cu Python). Motivația acestei decizii este reprezentată de a avea o perspectivă mai profundă a unui posibil algoritm de recomandare.

\section{Tehnologii folosite}

Pentru aplicația web:

\begin{enumerate}
  \item Baza de date: Neo4j.
  \item Server de back-end:
  \begin{itemize}
     \item Limbaj: Java versiunea 11
     \item Framework: Spring Boot
     \item REST API
   \end{itemize}
  \item Server de front-end:
  \begin{itemize}
     \item Limbaj: Typescript
     \item Framework: Angular
   \end{itemize}
\end{enumerate}
Pentru modulul de generare al datelor de intrare:

\begin{enumerate}
  \item API extern folosit pentru a procura date despre jocuri video: IGDB API \cite{1}
  \item API extern folosit pentru procurarea de recenzii de pe Steam \cite{2}
  \item Java Faker - pentru generarea de date aleatoare \cite{3}
  \item Apache Commons CSV - pentru manipularea de fișiere CSV \cite{4}
\end{enumerate}

\newpage

\section{Arhitectura sistemului}

Arhitectura sistemului ce propune rezolvarea problemei este următoarea:

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.5]{exemplu_17_diagrama_c4_nivel_1.drawio}
\caption*{Diagramă C4 nivelul 1}
\end{figure}

Se poate observa în ansamblu suita de tehnologii folosite: Neo4j pentru baza de date, Spring Boot pentru back-end și Angular pentru front-end.

Schema bazei de date va fi reprezentată în capitolul următor, deoarece înțelegerea acesteia presupune o scurtă inițiere în ceea ce propune Neo4j.

\newpage


\section{Baza de date}
\subsection{Introducere}

Tipul de stocare ales este cel oferit de Neo4j, în care se prezintă o abordare NoSQL de tip graf.  Comparativ cu o bază de date relațională, în care datele sunt stocate prin intermediul unor înregistrări(tuple) în tabele, în Neo4j datele sunt stocate prin intermediul nodurilor și muchiilor.

În exemplul următor, vor fi ilustrate caracteristicile nodurilor și muchiilor în stocarea efectivă a datelor:


\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale=0.5]{exemplu_1_neo4j}
\caption*{}
\end{figure}


Un nod în neo4j are următoarele caracteristici \cite{6}: reprezintă entități/obiecte, pot fi etichetate și pot avea proprietăți.

Observăm din figură cele trei entități: două noduri etichate cu 'Actor' și un nod etichetat cu 'Movie'. De asemenea, ambele noduri 'Actor' au proprietatea 'name', însă doar unul din ele are și proprietatea 'age'. Așadar, nu trebuie neapărat ca două noduri cu aceeași etichetă să aibă aceleași proprietăți.

Încă un lucru important de menționat este faptul că un nod poate avea mai multe etichete, așa cum se poate vedea din următorul exemplu:


\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale=0.5]{exemplu_2_neo4j}
\caption*{}
\end{figure}


Practic, din această figură se observă faptul că se poate modela cu ușurință situația în care un regizor joacă în propriul său film.

O altă noțiune importantă într-o bază de date de tip graf este cea de relație, care este asociată unei muchii. 
O relație trebuie să aibă un tip, un sens, și poate avea proprietăți.
Din figurile anterioare s-au putut observa relațiile \texttt{ACTS\_IN}, \texttt{DIRECTS\_IN} sau \texttt{IS\_FRIEND}.

Un alt aspect important de precizat este faptul că între două entități pot exista mai multe relații, așa cum s-a putut vedea în figura anterioară. Așadar, se modelează practic un multigraf orientat.

\subsection{De ce NoSQL și nu SQL?}

Având în vedere faptul că în această aplicație este prezentă o rețea socială în care mai mulți utilizatori pot interacționa între ei și pot oferi recenzii jocurilor video, o bază de date de tip graf este o alegere inspirată.

În ceea ce privește limbajul utilizat pentru a efectua interogări pe baza de date, avem în vedere următorul studiu de caz:

Să presupunem că dorim să modelăm ceea ce se întâmplă în cadrul unei facultăți, pe scurt: gestionarea studenților, a notelor pe care le iau aceștia la cursuri, și a profesorilor.
Exemplul ce urmează a fi ilustrat se bazează pe schema bazei de date ce a fost utilizată în cadrul materiei Baze de date din anul II semestrul I. \cite{7}

Să propunem că dorim să efectuăm următoarea interogare: pentru un student, să aflăm numele profesorilor la cursurile în care studentul a luat nota 10.

O interogare în limbajul SQL ar putea arăta în felul următor:

\begin{figure}[H]
\centering
\begin{BVerbatim}
SELECT p.nume, p.prenume FROM NOTE n 
JOIN CURSURI c ON n.id_curs = c.id
JOIN DIDACTIC d ON d.id_curs = c.id
JOIN PROFESORI p ON p.id = d.id_profesor
WHERE VALOARE = 10 AND ID_STUDENT = 36;
\end{BVerbatim}
\end{figure}


Se poate observa așadar faptul că sunt necesare o serie de join-uri pentru a putea obține rezultatul dorit.


Pentru a putea compara această interogare cu cea care s-ar putea face în limbajul Cypher folosit în Neo4j, se va ilustra pe scurt cum s-ar putea modela schema bazei de date anterior menționată în una de tip graf. (nu în totalitate, ci doar de ceea ce avem nevoie pentru a evidenția interogarea)


\begin{figure}[H]
\centering
\caption{Miniatură a schemei bazei de date}
\includegraphics[scale=0.4]{exemplu_3_neo4j}
\caption*{}
\end{figure}


Așadar, având în vedere acest model, interogarea în Cypher ar putea arăta în felul următor:

\begin{figure}[H]
\centering
\begin{BVerbatim}
MATCH (s:STUDENT)-[:ARE]->(n:NOTA {valoare: 10}),
(n)-[:LA]->(:CURS)<-[:PREDA]-(p:PROFESOR)
WHERE id(s) = 0
RETURN p.nume, p.prenume
\end{BVerbatim}
\end{figure}



Un prim lucru interesant care s-ar putea observa este faptul că Cypher introduce prin sintaxa sa conceptul de ASCII Art \cite{8}, \cite{9}, care practic face posibilă o nouă interpretare a codului, una vizuală, adică se poate observa relativ ușor cum ceea ce este scris în primele două linii de cod seamănă destul de mult cu modelul din figura anterioară.
Cele două linii s-ar fi putut scrie într-o singură linie fără nicio dificultate, însă am optat pentru această variantă pentru o mai bună lizibilitate a codului.

Pe de altă parte, o altă caracteristică importantă a bazelor de date de tip graf este că relațiile între entități au cea mai mare prioritate în modelarea datelor \cite{10}, acest lucru reflectându-se în modul cum a fost construită această interogare, în care este mult mai facil să interogăm niște date aflate la capătul unui lanț format din mai multe relații, așa cum se observă și în acest exemplu.

Pentru o mai bună înțelegere a modului în care sunt reprezentate efectiv datele, se poate vedea figura de mai jos:

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale=0.5]{exemplu_4_neo4j}
\caption*{Datele folosite pentru a exemplifica interogarea în Cypher}
\end{figure}

\subsection{Modelarea bazei de date}


Având în vedere noțiunile prezentate în capitolele anterioare, în acest capitol va fi descrisă schema bazei de date ce va fi folosită pentru a stoca datele necesare rezolvării problemei de a recomanda jocuri video.

Însă, înainte de a ilustra schema în ansamblu, fiecare entitate în parte va fi detaliată în rândurile următoare.

\bigskip
\textbf{Utilizatorul}
\bigskip

Această entitate reprezintă punctul central al aplicației, deoarece utilizatorul este cel care oferă recenzii(note) jocurilor și influențează într-un mod indirect recomandările unui alt utilizator, deci el este cel care, practic, inițiază acțiunea.

Nodul corespunzător acestei entități este cel din \textbf{Figura 5}.

Printre proprietățile alese pentru a reprezenta un utilizator, două dintre acestea reflectă activitatea lui în sistemul de recomandare, anume \emph{average\underline{ }score} și \emph{nr\underline{ }reviews\underline{ }made}, care semnifică numărul total de recenzii făcute de utilizator, respectiv scorul mediu al acestuia(media tuturor scorurilor oferite).

\bigskip
\textbf{Recenzia}
\bigskip

Recenzia reprezintă practic indicatorul calitativ pe care-l oferă un utilizator asupra unui joc. Așa cum se observă din 
\textbf{Figura 6}, o recenzie poate fi caracterizată prin proprietatea \emph{score}, nota oferită de utilizator jocului, proprietatea \emph{content}, care reprezintă un text ce poate fi introdus de utilizator pentru a-și exprima, dacă dorește, opinia sa asupra jocului, și proprietatea \emph{time}, adică momentul în care a făcut recenzia.

\bigskip
\textbf{Jocul}
\bigskip

Jocul indică resursa ce va fi recomandată de către utilizator și este punctul de interes al aplicației. Faptul că această entitate poate avea un număr relativ semnificativ de proprietăți reprezintă o provocare justificată, iar abordarea mea pentru a reprezenta această entitate se poate observa în 
\textbf{Figura 7}.


Pentru a nu suprasatura un nod cu multe proprietăți, am decis să împart acestea în funcție de categoria în care ar putea fi încadrate. Nodul principal \textbf{Game} are doar titlul, genurile și anul primei lansări, iar prin relația de tipul \texttt{HAS} se evidențiază nodurile care extind această entitate, și anume cel care conține proprietățile care indică elemente vizuale ale jocului(\emph{Visuals}), cel care conține date suplimentare despre joc(\emph{Details}) și cel care ține evidența legat de recenziile aplicate asupra jocului (\emph{Average}), unde proprietatea \emph{value} reprezintă scorul mediu al jocului(cât de bine este notat în medie de către utilizatorii sistemului), iar proprietatea \emph{aggregated\_rating} reprezintă scorul obținut dintr-o sursă externă(e.g. Metacritic)

\bigskip
\textbf{Schema bazei de date}
\bigskip

În \textbf{Figura 8}, având în vedere și aspectele menționate anterior legat de entitățile care formează în ansamblu schema bazei de date, se poate intui fluxul principal al aplicației. Utilizatorul introduce în profilul său ce jocuri video s-a jucat prin intermediul relației \texttt{PLAYS}, iar acțiunea prin care acesta efectuează o recenzie asupra jocului este reprezentată prin relația de tip \texttt{MAKES}. De asemenea, relația \texttt{ON} indică asupră cărei entități etichetată cu \emph{Game} se face recenzia.

Se poate deduce faptul că relațiile între noduri sunt numite astfel încât să reprezinte acțiuni ce pot fi efectuate sau aplicate asupra unor entități, ceea ce poate reprezenta un procedeu de bună practică în modelarea bazei de date în acest context. \cite{11}



\begin{figure}[H]
\centering
\caption{Utilizatorul}
\includegraphics[]{exemplu_6_neo4j}
\caption*{}
\end{figure}

\begin{figure}[H]
\centering
\caption{Recenzia}
\includegraphics[]{exemplu_7_neo4j}
\caption*{}
\end{figure}

\begin{figure}[H]
\centering
\caption{Jocul}
\includegraphics[scale = 0.6]{exemplu_8_neo4j}
\caption*{}
\end{figure}



\begin{figure}[H]
\centering
\caption{Schema bazei de date}
\includegraphics[scale=0.4]{exemplu_5_neo4j}
\caption*{Entitățile etichetate cu User, Game și Review mai au o proprietate în plus, și anume cea de id, care reprezintă un identificator unic pentru entitățile respective(uuid)}
\end{figure}

\subsection{Potențiale probleme}

\bigskip
\textbf{Constrângeri}
\bigskip

Am menționat atunci când am introdus capitolul de Baze de date faptul că două noduri care au aceeași etichetă nu trebuie să aibă neapărat aceleași proprietăți. Acest aspect face ca, în mod implicit, ca manipularea datelor să fie mult mai tolerabilă(cu mai puține constrângeri) în comparație cu o bază de date de tip SQL, unde acolo de exemplu trebuie să specificăm pentru o tabelă ce coloane să aibă și de ce tipuri să fie acestea.

Totuși, ce ar fi dacă am vrea să stabilim niște constrângeri? Poate am vrea să spunem de exemplu că o entitate etichetată cu User trebuie să aibă neapărat proprietățile \emph{username}, \emph{email} și \emph{password}, sau am vrea să setăm pentru o entitate cheia sa, ca să o putem identifica. Pentru a rezolva acest lucru, Neo4j introduce conceptul de constrângeri (\emph{constraints}) \cite{12}

Pentru a lucra facil cu baza noastră de date, Neo4j oferă o aplicație desktop ce vine cu un panou de comandă care oferă multe utilități. Putem executa de exemplu interogări în Cypher și să vizualizăm în mod interactiv graful obținut, cum se poate observa și în \textbf{Figura 4}.

În figura de mai jos, am realizat o captură în acest panou de comandă în care am scris comanda \texttt{SHOW CONSTRAINTS} unde pot vedea ce constrângeri sunt setate.

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.5]{exemplu_9_neo4j}
\caption*{Se pot observa constrângerile pe care le-am setat pentru entitatea User}
\end{figure}

\bigskip
\textbf{Modul în care se actualizează scorul mediu al utilizatorului și al nodului \emph{Average} asociat nodului \emph{Game}}
\bigskip

Am menționat atunci când am prezentat schema bazei de date de faptul că am dori să ținem cont de scorul mediu al utilizatorului și al jocului, și de numărul de recenzii al acestor entități. O variantă naivă pentru a rezolva această problemă este să calculăm valorile acestor proprietăți în serverul de back-end, parcurgând toate recenziile asociate unui utilizator/joc și calculând media aritmetică a scorurilor acestora de fiecare dată când se face o nouă recenzie de exemplu. Dacă avem relativ puține date, nu ar fi o problemă, însă atunci când numărul de recenzii, de jocuri sau de utilizatori crește semnificativ, atunci trebuie abordată o altă soluție pentru a eficientiza acest proces.

Neo4j introduce un alt concept, prin intermediul librăriei APOC \cite{13}, cel de declanșatoare
(\emph{triggers}). \cite{14}
Declanșatoarele sunt folosite pentru a executa cod în Cypher înainte sau după ce anumite date au fost modificate.

Așadar, am putea folosi un declanșator pentru a actualiza numărul de recenzii și scorul mediu pentru entitățile \emph{User} și \emph{Game} după ce o recenzie a fost creată.

Pentru a înțelege codul ce va fi prezentat ulterior, voi introduce un mic artificiu matematic pentru a înțelege cum se actualizează media scorurilor în acest caz.

\bigskip

Să presupunem că după \( k \) recenzii efectuate, scorul mediu este \( a_k \) și cea de a \( k+1 \) recenzie are scorul \( s \).

Pentru a reconstitui suma anterioară, aceasta reprezintă pur și simplu produsul dintre \( k \) și \( a_k \). Așadar, putem calcula noua medie, prin formula: 

\[ a_{k+1} = \frac{k \cdot a_k + s}{k+1} \]

Prin urmare, fiind introdusă această formulă, se poate prezenta codul ce va fi executat în cadrul declanșatorului, în rândurile următoare:

\begin{figure}[h]
\centering
\begin{BVerbatim}
 UNWIND \$createdRelationships AS r 
    MATCH (review:Review)-[r:ON]->(game:Game)
    MATCH (game)-[:HAS]->(average:Average)
    MATCH (u:User)-[:MAKES]->(review)-[:ON]->(game)
    SET average.value = toFloat(
    average.nr_reviews * average.value + toInteger(review.score)
    ) / (average.nr_reviews + 1),
	average.nr_reviews = average.nr_reviews + 1,
    u.average_score = toFloat(
    u.nr_reviews_made * u.average_score + toInteger(review.score)
    ) / (u.nr_reviews_made + 1),
    u.nr_reviews_made = u.nr_reviews_made + 1
\end{BVerbatim}
\caption*{A se ignora simbolul \textbackslash{ } înainte de createdRelationships}
\end{figure}

Așadar, de fiecare dată după ce se creează o relație de tipul \texttt{ON} între nodurile \emph{Review} și \emph{Game}, atunci vom interoga nodurile \emph{Average} și \emph{User} pe care dorim să le actualizăm folosind formula anterioară.

\subsection{Generarea datelor de intrare}

Neo4j oferă funcționalitatea de a importa date prin intermediul fișierelor CSV, iar prin intermediul limbajului Cypher, pot fi create noduri și relații cu aceste date pentru a crea schema de baze de date.

Din intenția de a-mi modela baza de date după bunul meu plac, nu am vrut să optez pentru a lua un set de date deja gata făcut, ci am implementat un submodul în limbajul Java(separat de aplicația web propriu-zisă) care extrage date ori din API-uri externe(menționate la capitolul \textbf{Tehnologii și resurse folosite}, ori din fișiere salvate local, și generează fișiere CSV pentru a le putea importa apoi în baza de date.

\bigskip
\textbf{Generarea utilizatorilor}
\bigskip

Pentru a-mi genera utilizatorii fictivi ai aplicației, am apelat la librăria Java Faker. Aceasta m-a ajutat ca să generez nume de utilizator, parole și adrese de e-mail. În ceea ce privește parolele, am generat prin intermediul acestei librării un șir de caractere \emph{random} format din 8 caractere, ce conține cifre și litere. De asemenea, pe această parolă am aplicat o funcție hash, cu scopul de a nu fi stocată parola originală în baza de date, deci pentru a avea un strat de securitate în acest caz. Am ales să utilizez algoritmul PBKDF2 în convertirea parolei deoarece este o variantă sigură. \cite{15}

Așadar, cu valorile generate, am creat două fișiere CSV în care rețin 500 de utilizatori(un fișier cu parolele originale, celălalt cu parolele convertite prin funcția hash)

O observație importantă este că atât pentru utilizator, cât și pentru celelalte entități, am generat și un identificator unic, prin intermediul utilitarului UUID oferit de Java.

\bigskip
\textbf{Generarea jocurilor}
\bigskip

Pentru a-mi procura jocurile, m-am folosit de API-ul oferit de cătrei cei de la IGDB.

Pentru a putea utiliza acest API, a fost necesară crearea unui cont pe Twitch, iar prin intermediul acestui cont, mi-am generat un \emph{Client ID} și un \emph{Client Secret}. Cu aceste credențiale, am generat un \emph{token} pe care l-am folosit ca să pot accesa după API-ul menționat. Mai multe detalii pot fi regăsite aici. \cite{16}

În figura următoare, am atașat o bucată de cod prin care se poate observa cum utilizez acest API pentru a procura jocurile.

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.6]{exemplu_10_games}
\caption*{Așadar, acele proprietăți enumerate în proprietatea FIELDS sunt practic cele folosite pentru modelarea entității \emph{Game} din baza de date. Am procurat 300 de jocuri pe care le-am sortat descrescător după proprietatea \emph{follows} pentru a mă asigura că voi lua cele mai populare jocuri cu putință. }
\end{figure}

După ce am obținut jocurile, am împărțit proprietățile așa cum am menționat la subcapitolul \textbf{Modelarea bazei de date} și am creat 4 fișiere CSV (games.csv, details.csv, visuals.csv, average.csv)

\bigskip
\textbf{Algoritmul lui Durstenfield}
\bigskip

Înainte de a trece la secțiunile următoare, am să prezint un algoritm care extrage în mod \emph{random} un număr de \( k\) elemente dintr-o listă cu scopul de a-l folosi în repartizarea jocurilor și a recenziilor cățre fiecare utilizator.

Acest algoritm a fost introdus de către Richard Durstenfield și este o variantă modernizată a aloritmului Fisher-Yates. \cite{16} Aceasta presupune parcurgerea listei(ori de la capăt, ori de la început) și schimbarea elementului curent cu un element ales în mod \emph{random}. Dacă toată lista este parcursă, atunci vom obține o permutare a listei inițiale.

Deoarece avem de extras \( k \) elemente din listă, atunci nu e nevoie să parcurgem toată lista, ci doar primele/ultimele \( k \) elemente. După aceste \( k \) schimbări, putem extrage elementele dorite, ori de la începutul, ori de la sfârșitul listei.

O variantă de implementare a algoritmului în limbajul Java ar putea arăta în felul următor:

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.8]{exemplu_11_random}
\caption*{Complexitatea acestui algoritm este \(\mathcal{O}(n) \), cu condiția ca metoda care alege în mod întâmplător elementul care trebuie schimbat să se facă în complexitate \(\mathcal{O}(1) \) }
\end{figure}

\bigskip
\textbf{Repartizarea jocurilor jucate către fiecare utilizator}
\bigskip

În această secțiune se poate observa deja utilitatea algoritmului menționat anterior. Pentru fiecare utilizator, am ales la întâmplare 20 de jocuri din cele 300 generate, iar aceste asocieri le-am salvat în fișierul plays.csv

Acest fișier arată în felul următor:

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.8]{exemplu_12_plays}
\caption*{De menționat faptul că în coloana id\_games\_played sunt salvate niște liste de uuid-uri. În mod intuitiv, fișierele CSV generate ar putea fi asociate cu tabele dintr-o bază de date relațională. În acest caz, dacă am ignora faptul că id-urile jocurilor sunt reținute sub forma unei liste, am putea asocia conținutul fișierului plays.csv cu o tabelă asociativă. Practic aici se identifică o relație de mai mulți la mai mulți(un utilizator poate avea mai multe jocuri, iar un joc poate fi jucat de mai mulți utilizatori) }
\end{figure}

\bigskip
\textbf{Generarea recenziilor și repartizarea acestora către fiecare utilizator}
\bigskip

În această secțiune, am folosit atât API-ul oferit de Steam pentru a obține recenziile unui joc, dar și fișiere salvate local pentru a încerca să optimizez cât mai mult timpul necesar pentru a fi generate toate fișierele.

Primul pas a fost să salvez într-un fișier local în format JSON jocurile oferite de Steam, sub forma unei liste de obiecte, în care fiecare obiect are două proprietăți:  \emph{appid}(un identificator unic folosit de Steam pentru jocurile sale) și \emph{name}(numele jocului). Scopul acestui fișier este de a încerca să identific dacă jocul procurat inițial de la IGDB API poate fi identificat ca un joc din platforma Steam ca să pot extrage ulterior recenzii relevante acestui joc. (prin intermediul API-ului oferit de Steam). În caz contrar, voi extrage o recenzie aleatoare dintr-un fișier salvat local de tip csv dintr-un set de date oferit de Kaggle. \cite{17}

Al doilea pas a fost să asociez fiecărui utilizator un număr de recenzii pe care le poate oferi din cele 20 de jocuri pe care le-am repartizat. Inițial am extras din cele 20 de jocuri un număr din acestea stabilit în felul următor:

\bigskip

Voi genera un număr întreg în intervalul \([0, 5) \) cu probabilitate de \(0.2 \), și cu probabilitate de \( 0.8 \) un număr în intervalul \([5, 20] \). Motivul pentru care am procedat astfel este ca să sporesc șansele ca doi utilizatori să aibă cât mai multe jocuri în comun la care au făcut recenzii. Am sporit aceste șanse pentru algoritmul de recomandare ce va fi descris într-un capitol ulterior.

În mod intuitiv, acest procedeu poate fi asociat prin alegerea unei urne din 2 disponibile. O urnă are probabilitate \( 0.2 \) de a fi aleasă, iar cealaltă urnă are probabilitate \( 0.8 \). În fiecare urnă, bilele(în cazul nostru numerele întregi) au aceeași probabilitate de a fi alese.(adică urmează o distribuție uniformă).

\bigskip

După ce am determinat acest număr, voi extrage acel număr de jocuri propriu-zis, după care voi încerca să asociez pentru fiecare joc câte o recenzie. 

Pentru a fi mai ușor de explicat, următorii pași îi voi ilustra sub forma unui pseudocod, iar după acest pseudocod va fi prezentat codul propriu-zis în Java, pentru a fi mai ușor de înțeles.

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.8]{exemplu_13_review_code}
\caption*{La o primă vedere, acest procedeu nu este complicat, însă dificultatea constă în extragerea unei recenzii pentru un joc aflat pe platforma Steam, deoarece trebuie gestionată frecvența \emph{request}-urilor care se fac către API-ul care ne oferă recenziile în acest caz. De menționat faptul că acest procedeu se realizează pentru fiecare utilizator.}
\end{figure}

O modalitate naivă este de a face un \emph{request} de fiecare dată când dorim să asociem o recenzie unui joc, însă numărul de \emph{request-uri} crește cu cât mărim numărul de utilizatori și de jocuri recenzate de fiecare utilizator. În cazul de față, avem \(500\) de utilizatori, iar în cel mai rău caz, pentru fiecare utilizator avem \(20\) de recenzii, deci în total \(10 000 \) de \emph{request}-uri.

Să presupunem că timpul mediu în care s-ar face un request este de \( 20 \) milisecunde.(un timp foarte bun în practică) În total ar dura \( 10 000 \cdot 20 = 200000 \approx 3 \) minute, ceea ce este un timp deloc neglijabil în acest context.

O observație importantă este faptul că un joc căruia i se extrage o recenzie este foarte posibil să se repete atunci când se parcurg utilizatorii. De asemenea, nu suntem constrânși de către API să extragem fix o recenzie, putem extrage mai multe dacă se dorește acest lucru, ceea ce sporește varietatea recenziilor pentru același joc, în cazul în care se repetă.

O structură de date folositoare oferită de limbajul Java pentru a fructifica acest aspect este cea numită \emph{Map}, în care se rețin perechi tip cheie-valoare. În contextul nostru, cheia este un joc, iar valoarea este reprezentată de recenziile jocului, sub forma unui JSON. Inițializarea acestuia ar putea arăta în felul următor:

\begin{verbatim}
  private final Map<SteamGame, JsonNode> reviewsRegistry = new HashMap<>();
\end{verbatim}

Așadar, dacă jocul există deja în această structură de date, atunci voi extrage o recenzie deja stocată. În caz contrar, voi face un \emph{request} pentru a obține recenziile.

Codul implementat în Java arată în felul următor:

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.7]{exemplu_14_review_code_java}
\caption*{Se poate observa folosirea proprietății \emph{votedUp}, pusă la dispoziție de către API-ul responsabil de recenzii de la Steam, prin care verific dacă acea recenzie a fost pozitivă sau negativă. În funcție de acest verdict, încerc să generez un scor care să reflecte cât mai mult realitatea.}
\end{figure}

Așadar, acesta este submodulul care se ocupă de generarea fișierelor CSV necesare pentru a putea importa conținutul acestora în baza de date.

\subsection{Importarea conținutului fișierelor CSV în baza de date}

Modul prin care sunt importate aceste date este prin intermediul limbajului Cypher, mai concret prin comanda \texttt{LOAD CSV} ce face parte din acest limbaj \cite{18}.

Un exemplu de cod în Cypher în care îmi creez recenziile generate poate fi acesta:

\begin{figure}[H]
\centering
\begin{BVerbatim}
LOAD CSV WITH HEADERS
FROM 'file:///reviews.csv'
AS line
MATCH(u:User {id: line.id_user})
MATCH(g:Game {id: line.id_game})
MERGE(r:Review {id: line.id_review})
    ON CREATE SET r.score = line.score,
                  r.content = line.content,
                  r.time = line.time
MERGE (u)-[:MAKES]->(r)-[:ON]->(g)
\end{BVerbatim}
\caption*{Un element de noutate este reprezentat de clauza \texttt{MERGE}. Prin aceasta putem verifica, în acest caz, dacă nodul \emph{Review} a fost creat sau există deja. În cazul în care este creat, atunci vor fi setate proprietățile aferente. În cazul în care acest cod ar fi rulat a doua oară(fără alte modificări în prealabil), atunci nu va fi creat niciun nod nou, deci practic nu va mai avea niciun efact.}
\end{figure}

De-a lungul timpului cât am dezvoltat acest submodul de generare a fișierelor CSV, am întâmpinat uneori dificultăți care au făcut necesare ștergerea datelor din baza de date și reintroducerea acestora cu modificările aferente. Pentru a ușura acest proces, Neo4j oferă prin intermediul panoului de comandă o secțiune prin care se pot marca coduri în Cypher ca favorite și pot fi executate ori de câte ori este nevoie.

Practic, mi-am salvat o serie de coduri în secțiunea de favorite pe care le pot executa în ordine atunci când este nevoie. 

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.8]{exemplu_15_favorites}
\caption*{}
\end{figure}

În ceea ce privește ștergerea întregului conținut al bazei de date, aceasta trebuie făcută cu grijă. Neo4j recomandă mai multe alternative prin care acest procedeu poate fi făcut utilizându-se cele mai bune practici, pentru a evita efecte secundare neplăcute. \cite{19}

Varianta pentru care am optat este următoarea:

\begin{figure}[H]
\centering
\begin{BVerbatim}
CALL apoc.periodic.iterate(
"MATCH (n) return id(n) as id",
"MATCH (n) WHERE id(n) = id DETACH DELETE n", 
{batchSize: 10000}
)
YIELD batches, total RETURN batches, total
\end{BVerbatim}
\caption*{Practic, prin intermediul librăriei APOC, șterg toate nodurile(cu tot cu relațiile asociate) în grupuri de câte 10000 de noduri.}
\end{figure}

După ce am importat datele, putem interacționa cu acestea prin intermediul panoului de comandă ca să se poată verifica dacă datele au fost întradevăr, introduse corect.

Una din modalitățile interesante prin care putem verifica asta este dacă schema bazei de date care a fost descrisă în subcapitolul \textbf{4.3 Modelarea bazei de date } se potrivește cu cea pe care o putem vizualiza în mod interactiv prin intermediul comenzii \texttt{CALL db.schema.visualization()}

Rezultatul acestei comenzi este reprezentat în figura de mai jos:

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.7]{exemplu_16_schema}
\caption*{}
\end{figure}



\section{Back-end}

\subsection{De ce Java? De ce Spring Boot?}

Soluția aleasă pentru a stoca datele este una relativ de nișă, având în vedere caracteristica de NoSql a bazei de date Neo4j, dar și de faptul că are la bază o reprezentare de tip graf. Așadar, studiind soluțile oferite din această documentație \cite{20} legată de limbajele suportate de Neo4j, am observat că Java este singurul limbaj în care Neo4j oferă capabilitatea de a mapa nodurile ce se regăsesc în baza de date în entități, ceea ce oferă un mod de lucru facil cu o perspectivă de ansamblu mult mai mare, în comparație cu un \emph{driver} în care modul de lucru este unul mult mai elaborat. Această soluție se numește \emph{Spring Data Neo4j}. \cite{21}

Având în vedere faptul că capabilitățile de a lucra mult mai facil cu baza de date se regăsesc în suita Spring, am ales să utilizez Spring Boot pentru a implementa serverul de back-end. Faptul că am avut o introducere în acest \emph{framework} în cadrul materiei \emph{Programare avansată} din anul 2 semestrul 2 de studiu mi-a dat un punct de pornire consistent pentru a dezvolta această parte de back-end.


\subsection{Modelarea nodurilor în entități}

Așa cum am menționat la introducerea acestui capitol, soluția folosită pentru a mapa nodurile în entități este cea oferită de \emph{Spring Data Neo4j}.

Această mapare presupune reprezentarea nodurilor din schema bazei de date (\emph{User}, \emph{Review} și \emph{Game}) sub forma unor clase(entități) care pot fi utilizate pe partea de back-end. O instanță a acestei clase reprezintă practic un nod din baza de date.

La baza acestor mapări stau adnotările, iar cele care au fost utilizate în cadrul aplicației în mod frecvent sunt: \emph{@Id}, \emph{@Property}, \emph{@Relationship}. Pentru a explica utilizarea lor, va fi reprezentată următoarea figură:

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.8]{exemplu_18_adnotari}
\caption*{Entitatea \emph{Game}}
\end{figure}

În primul rând, se observă adnotarea clasei \emph{GameEntity} cu \emph{@Node("Game")}, care asociază reprezentarea acestei clase cu cea a nodului din schema bazei de date etichetat cu "Game".

Cu adnotarea \emph{@Id} se specifică proprietatea care identifică în mod unic o entitate. Având în vedere faptul că se utilizează \emph{uuid}-uri, adnotarea \emph{@GeneratedValue} ajută la specificarea unui generator care face în mod automat un \emph{uuid}, un aspect util atunci când se instanțiază o nouă entitate, de exemplu.

Adnotarea \emph{@Property} este utilă pentru a asocia proprietățile corespunzătoare nodurilor din schema bazei de date cu proprietățile din această clasă.(e.g. proprietățile \emph{title}, \emph{genres}, \emph{firstReleaseYear})

Adnotarea \emph{@Relationship} este utilă atunci când se dorește ținerea în evidență a relațiilor pe care le poate avea entitatea definită cu celelalte entități. În acest caz, cum nodul \emph{Game} are cele trei noduri \emph{Visuals}, \emph{Details} și \emph{Average} care îl extind pe acesta, se poate observa în mod intuitiv utilizarea acestei adnotări. O relație este definită prin intermediul unui tip și al unei direcții("înspre" entitatea definită, sau "în afara" entității.) De asemenea, se observă ținerea în evidență a recenziilor care s-au făcut asupra jocului.

O observație importantă în ceea ce privește încărcarea datelor asociate unei relații, este faptul că aceasta se face doar atunci când este în mod explicit nevoie. De exemplu, dacă am dori să obținem o entitate \emph{GameEntity} în funcție de \emph{uuid}, atunci datele obținute sunt doar cele aferente proprietăților(adică nu se vor încărca datele asociate nodurilor \emph{Visuals}, \emph{Details} și \emph{Average}) pentru un plus de performanță.

Pentru a avea mai mult control asupra datelor ce se doresc a fi obținute, va fi prezentată secțiunea următoare.

\subsection{Interfața Repository și conceptul de Interface Projection}

Scopul interfeței Repository este de a oferi un mod abstract și facil prin intermediul căruia este implementat un strat de acces care poate fi utilizat pentru a reduce în mod semnificativ codul implementat în interacționarea cu datele. \cite{22}

Această interfață este definită în mod generic, luând doi parametrii: numele entității care va fi prelucrată și tipul de date al identificatorului(în cazul de față \emph{String})

Metodele specifice acestei interfețe fac parte din repertoriul CRUD(Create, Read, Update, Delete.)

Un exemplu de definire a acestei entități poate fi observat în figura următoare:

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.8]{exemplu_19_repository}
\caption*{Interfața de tip \emph{Neo4jRepository} specifică entității \emph{GameEntity}}
\end{figure}

În mod convențional, metodele sunt numite astfel încât să se poată observa tipul operației, folosindu-se cuvinte cheie precum \emph{find}, \emph{by}, \emph{save}, iar implementarea acestora se face în mod automat la \emph{runtime}. În exemplul din figură, metodele sunt de tipul Read: una pentru a obține toate jocurile stocate, una pentru a obține un joc după un \emph{uuid}, și una pentru a obține jocurile prin intermediul paginării(de exemplu: o pagină de 5 jocuri)

Se oferă suport și pentru definirea unor metode \emph{custom} în cazul în care este nevoie de obținerea unui rezultat în urma unei interogări în limbajul \emph{Cypher}, însă mai multe detalii legat de acest aspect se pot regăsi în capitolul 6 \textbf{Algoritmul de recomandare}.

De asemenea, se poate observa apariția conceptului de \emph{Interface Projection}, prin care se poate preciza prin intermediul unei interfețe ce date să fie prelucrate dintr-o entitate. 

În cazul de față, să presupunem că dorim să avem pentru entiatea \emph{GameEntity} și acele date care extind nodul \emph{Game} aferent din baza de date (\emph{Visuals}, \emph{Details} și \emph{Average}). Așadar, putem să ne definim o interfață(de exemplu cu numele de \emph{GameInterfaceProjection}) care precizează datele de care avem nevoie. Aceasta arată în felul următor:

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 1]{exemplu_20_interface_projection}
\caption*{Un lucru interesant de menționat este faptul că aceste proiecții pot fi definite în mod recursiv. În cazul de față, \emph{Visuals}, \emph{Details} și \emph{Average} sunt de asemenea entități, și datele acestora pot fi controlate separat prin intermediul unui \emph{Interface Projection} specific.}
\end{figure}


\subsection{REST API}

Modul prin care funcționalitățile de pe back-end sunt expuse spre a fi folosite de către serverul de front-end este prin intermediul unui REST API, în care resursele oferite sunt reprezentate sub format JSON.

Expunerea acestor funcționalități s-a făcut prin intermediul \emph{Controller}-elor: \emph{UserController}, \emph{GameController} și \emph{ReviewController}. Acestea utilizează în mod intern servicii implementate care se utilizează de metodele din \emph{repository}. De exemplu, se poate regăsi în figura de mai jos modul cum a fost definit \emph{ReviewController}:

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.7]{exemplu_21_review_controller}
\caption*{}
\end{figure}

Adnotările sunt și în acest caz destul de sugestive. Practic, sunt definite mai multe \emph{request-uri} de tipul GET ce pot fi accesate prin intermediul protocolului HTTP. Acestea au rolul de a oferi resurse(recenzii), mai concret ori toate recenziile disponibile, ori o recenzie în funcție de id, ori toate recenziile făcute de un utilizator, ori toate recenziile făcute asupra unui joc.

Adnotarea \emph{@Autowired} denotă faptul că instanța serviciului \emph{ReviewService} este injectată spre a fi folosită în acest controller. Acest aspect ilustrează conceptul de \emph{Dependency Injection}, care are ca scop reducerea cuplării. \cite{23}

Acest serviciu este responsabil de procurarea datelor necesare prin intermediul \emph{repository-urilor} definite.

Modul cum a fost implementat se regăsește în următoarea figură:

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.65]{exemplu_22_review_service}
\caption*{}
\end{figure}

Se poate observa că implementarea propriu-zisă este aproape trivială în acest caz. Totuși, o implementare netrivială se poate regăsi în capitolul 6 \textbf{Algoritmul de recomandare}.





\subsection{Modulul de autentificare al utilizatorilor}


   Acest modul are un scop relativ simplu, fiind reprezentat de valorificarea fișierului csv în care sunt reținute parolele convertite de funcția hash, dar și de a persista starea de logare a utilizatorului pe partea de front-end a aplicației, prin intermediul unui JWT token. \cite{24}

Implementarea acestuia reprezintă doar un punct de pornire, căci poate fi extins și prin introducerea autorizării, în care anumite \emph{request-uri} din API pot fi autorizate în funcție de rolul pe care îl are utilizatorul prin intermediul token-ului menționat anterior. Totuși, pentru scopul în mare al proiectului, acela de a observa cum se poate rezolva problema recomandării unor jocuri video, acest aspect de autentificare/autorizare nu a fost atins foarte în detaliu.

Pentru a implementa acest modul, am utilizat funcționalitățile oferite de \emph{Spring Security}. \cite{25}

În general, o aplicație web Spring are la bază un \emph{Dispatcher Servlet}, care, în mod intuitiv conform numelui, acționează ca un dispecer care verifică ce \emph{request} s-a făcut și îl asociază cu unul definit în cadrul unui metode din \emph{Controller}. \cite{26}

Totuși, nu am menționat niciun aspect legat de securitate, iar de acest lucru se ocupă \emph{Spring Security}, care în linii mari include posibilitatea de a adăuga unul sau mai multe filtre înainte de a acționa acel \emph{Dispatcher Servlet}.

Pentru a stabili aceste filtre, am suprascris anumite metode din cadrul clasei abstracte \emph{WebSecurityConfigurerAdapter} în clasa numită \emph{WebSecurityConfig} în felul următor:

\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.7]{exemplu_23_security}
\caption*{}
\end{figure}

În stadiul actual, practic orice \emph{request} are cale liberă spre a fi folosit, însă acest lucru poate fi bineînțeles schimbat ulterior prin autorizarea \emph{request}-urilor în funcție de rolurile utilizatorului.

De asemenea, a fost implementat un \emph{userService} care are rolul de a prelua un utilizator după \emph{username}-ul său.

Punctul de interes îl reprezintă acel \emph{CustomAuthenticationFilter} care prelucrează credențialele
(numele de utilizator și parola) din cadrul \emph{request}-ului care se ocupă de autentificarea unui utilizator, și acționează corespunzător dacă autentificarea s-a efectuat cu succes sau nu. În caz pozitiv, acest \emph{request} va furniza un JWT token ce va fi folosit de către aplicația de front-end pentru a persista logarea utilizatorului.

O variantă de implementare concretă a furnizării acelui \emph{token} poate fi următoarea:


\begin{figure}[H]
\centering
\caption{}
\includegraphics[scale = 0.75]{exemplu_24_jwt}
\caption*{}
\end{figure}

De menționat faptul că acel secret care este pus manual pentru a fi folosit în semnarea \emph{token}-ului prin intermediul algoritmului HMAC nu este o metodă bună în practică(în contextul unei eventuale lansări ipotetice a aplicației în producție), însă în scopul de față, acest aspect nu reprezintă un inconvenient major.


\newpage



\section{Algoritmul de recomandare}

Documentația pe care am consultat-o în scopul implementării acestui algoritm constă într-un curs de pe Udemy. \cite{27} Chiar dacă în acest curs noțiunile sunt prezentate având ca limbaj suport Python, intenția mea a fost de a înțelege mai degrabă conceptele și de a le implementa utilizând limbajul Java și baza de date Neo4j.

\subsection{Introducere}

\section{Front-end}
\section{Manual de utilizare}
\section{Concluzii și direcții viitoare}

\renewcommand\bibname{Bibliografie}
\begin{thebibliography}{9}

\bibitem{igdb-api}
  
  \textit{IGDB API}
  
  \url{https://www.igdb.com/api}
  
  \url{https://github.com/husnjak/IGDB-API-JVM}
  
\bibitem{steam-reviews}
  
  \textit{Steamworks Documentation - Reviews}
  
  \url{https://partner.steamgames.com/doc/store/getreviews}
  
\bibitem{java-faker}
  
  \textit{Java Faker}
  
  \url{https://github.com/DiUS/java-faker}
  
\bibitem{apache-commons-csv}
  
  \textit{Apache Commons CSV}
  
  \url{https://commons.apache.org/proper/commons-csv/}


\bibitem{lamport94}
  
  \textit{Recommendation systems: Principles, methods and evaluation},
  2015.
  
  F.O. Isinkaye, Y.O. Folajimi, B.A. Ojokoh
  
  \url{https://www.sciencedirect.com/science/article/pii/S1110866515000341}
  
  \bibitem{graphDatabase}
  
  \textit{What is a graph database?}
  
  \url{https://neo4j.com/developer/graph-database/}
  
  \bibitem{7}
  
  \textit{Baze de date}
  
  \url{https://profs.info.uaic.ro/~bd/}
  
  \bibitem{8}
  
  \textit{Neo4j Training - Querying with Cypher In Neo4j 4.x}
  
  \url{https://neo4j.com/graphacademy/training-querying-40/01-querying40-introduction-to-cypher/}
  
  \bibitem{9}
  
  \textit{ASCII art}
  
  \url{https://en.wikipedia.org/wiki/ASCII_art}
  
  \bibitem{10}
  
  \textit{Neo4j Training - Overview of Neo4j 4.x - Neo4j is a Graph Database  }
  
  \url{https://neo4j.com/graphacademy/training-overview-40/01-overview40-neo4j-graph-database/}
  
  \bibitem{11}
  
  \textit{Graph Modeling Guidelines}
  
  \url{https://neo4j.com/developer/guide-data-modeling/}
  
  \bibitem{12}
  
  \textit{Constraints}
  
  \url{https://neo4j.com/docs/cypher-manual/current/constraints/}
  
  \bibitem{13}
  
  \textit{APOC Documentation / Introduction}
  
  \url{https://neo4j.com/labs/apoc/4.1/introduction/}
  
  \bibitem{14}
  
  \textit{Triggers}
  
  \url{https://neo4j.com/labs/apoc/4.1/background-operations/triggers/}
  
  \bibitem{15}
  
  \textit{Hashing a Password in Java}
  
  \url{https://www.baeldung.com/java-password-hashing}
  
  \bibitem{16}
  
  \textit{Fisher–Yates shuffle}
  
  \url{https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle}
  
  \bibitem{17}
  
  \textit{Steam Game Review Dataset}
  
  \url{https://www.kaggle.com/datasets/arashnic/game-review-dataset}
  
  \bibitem{18}
  
  \textit{Importing CSV Data into Neo4j}
  
  \url{https://neo4j.com/developer/guide-import-csv/}
  
  \bibitem{19}
  
  \textit{Large Delete Transaction Best Practices in Neo4j}
  
  \url{https://neo4j.com/developer/kb/large-delete-transaction-best-practices-in-neo4j/}
  
  \bibitem{20}
  
  \textit{Drivers \& Language Guides}
  
  \url{https://neo4j.com/developer/language-guides/}
  
  \bibitem{21}
  
  \textit{Spring Data Neo4j}
  
  \url{https://neo4j.com/developer/spring-data-neo4j/}
  
  \bibitem{22}
  
  \textit{Working with Spring Data Repositories}
  
  \url{https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#repositories}
  
  \bibitem{23}
  
  \textit{Spring Dependency Injection}
  
  \url{https://www.baeldung.com/spring-dependency-injection}
  
  \bibitem{24}
  
  \textit{Introduction to JSON Web Tokens}
  
  \url{https://jwt.io/introduction}
  
  \bibitem{25}
  
  \textit{Spring Security}
  
  \url{https://spring.io/projects/spring-security}
  
  \bibitem{26}
  
  \textit{Spring Security: Authentication and Authorization In-Depth}
  
  \url{https://www.marcobehler.com/guides/spring-security}
  
  \bibitem{27}
  
  \textit{Recommender Systems and Deep Learning in Python}
  
  \url{https://www.udemy.com/course/recommender-systems/}


\end{thebibliography}

\end{document}
